// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var MimeTypes = require("mime-types");
var Caml_option = require("rescript/lib/js/caml_option.js");
var Core__Array = require("@rescript/core/lib/js/src/Core__Array.res.js");
var Promises = require("fs/promises");
var Core__Option = require("@rescript/core/lib/js/src/Core__Option.res.js");
var ClientS3 = require("@aws-sdk/client-s3");
var LibStorage = require("@aws-sdk/lib-storage");

function toString(environment) {
  if (environment === "Development") {
    return "DEV";
  } else {
    return "PROD";
  }
}

var Environment = {
  toString: toString
};

function getBucket(environment) {
  if (environment === "Development") {
    return "practice-tool-dev";
  } else {
    return "practice-tool";
  }
}

async function ls(environment) {
  var match = await new ClientS3.S3Client({}).send(new ClientS3.ListObjectsCommand({
            Bucket: getBucket(environment)
          }));
  return Core__Option.getOr(match.Contents, []).map(function (param) {
              return param.Key;
            });
}

async function rm(environment) {
  var bucket = getBucket(environment);
  console.log("Deleting content of %s bucket", toString(environment));
  var files = await ls(environment);
  var results = await Promise.all(files.map(async function (key) {
            var result = await new ClientS3.S3Client({}).send(new ClientS3.DeleteObjectCommand({
                      Bucket: bucket,
                      Key: key
                    }));
            if (result.$metadata.httpStatusCode >= 400) {
              console.error("Failed to delete a file %s: %o", key, result);
              return key;
            }
            
          }));
  if (Core__Array.keepSome(results).length === 0) {
    console.log("%d files successfully deleted from %s bucket", files.length, toString(environment));
    return ;
  }
  
}

async function cp(environment) {
  var bucket = getBucket(environment);
  console.log("Uploading frontend to %s bucket", toString(environment));
  var files = await Promises.readdir("/home/filip/development/practice-tool-rescript/frontend/out", {
        withFileTypes: true,
        recursive: true
      });
  var results = await Promise.all(Core__Array.filterMap(files, (function (file) {
                    if (file.isDirectory()) {
                      return ;
                    } else {
                      return file.parentPath + "/" + file.name;
                    }
                  })).map(async function (filePath) {
                var body = await Promises.readFile(filePath);
                return {
                        Bucket: bucket,
                        Key: filePath.substring(filePath.indexOf("/out") + 5 | 0),
                        Body: body,
                        ContentType: Core__Option.getOr(Caml_option.nullable_to_opt(MimeTypes.lookup(filePath)), "")
                      };
              }).map(async function (params) {
              var params$1 = await params;
              return new LibStorage.Upload({
                          client: new ClientS3.S3Client({}),
                          params: params$1,
                          queueSize: 3
                        });
            }).map(async function (upload) {
            var upload$1 = await upload;
            return await upload$1.done();
          }));
  console.log("%d files successfully uploaded to %s bucket", results.length, toString(environment));
}

var basePath = "/home/filip/development/practice-tool-rescript/frontend";

var dotEnvFilePath = basePath + "/.env";

exports.Environment = Environment;
exports.getBucket = getBucket;
exports.ls = ls;
exports.rm = rm;
exports.cp = cp;
exports.basePath = basePath;
exports.dotEnvFilePath = dotEnvFilePath;
/* mime-types Not a pure module */
